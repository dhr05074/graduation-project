// Code generated by cmd/cgo; DO NOT EDIT.

//line /go/pkg/mod/github.com/envoyproxy/envoy@v1.27.1/contrib/golang/filters/http/source/go/pkg/http/capi_impl.go:1:1
/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package http

/*
// ref https://github.com/golang/go/issues/25832

#cgo CFLAGS: -I../../../../../../common/go/api -I../api
#cgo linux LDFLAGS: -Wl,-unresolved-symbols=ignore-all
#cgo darwin LDFLAGS: -Wl,-undefined,dynamic_lookup

#include <stdlib.h>
#include <string.h>

#include "api.h"

*/
import _ "unsafe"
import (
	"reflect"
	"runtime"
	"strings"
	"sync/atomic"
	"unsafe"

	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/known/structpb"

	"github.com/envoyproxy/envoy/contrib/golang/common/go/api"
)

const (
	ValueRouteName               = 1
	ValueFilterChainName         = 2
	ValueProtocol                = 3
	ValueResponseCode            = 4
	ValueResponseCodeDetails     = 5
	ValueAttemptCount            = 6
	ValueDownstreamLocalAddress  = 7
	ValueDownstreamRemoteAddress = 8
	ValueUpstreamLocalAddress    = 9
	ValueUpstreamRemoteAddress   = 10
	ValueUpstreamClusterName     = 11
	ValueVirtualClusterName      = 12
)

type httpCApiImpl struct{}

// Only CAPIOK is expected, otherwise, it means unexpected stage when invoke C API,
// panic here and it will be recover in the Go entry function.
func handleCApiStatus(status  /*line :66:30*/_Ctype_CAPIStatus /*line :66:42*/) {
	switch status {
	case ( /*line :68:7*/_Ciconst_CAPIOK /*line :68:14*/):
		return
	case ( /*line :70:7*/_Ciconst_CAPIFilterIsGone /*line :70:24*/):
		panic(errRequestFinished)
	case ( /*line :72:7*/_Ciconst_CAPIFilterIsDestroy /*line :72:27*/):
		panic(errFilterDestroyed)
	case ( /*line :74:7*/_Ciconst_CAPINotInGo /*line :74:19*/):
		panic(errNotInGo)
	case ( /*line :76:7*/_Ciconst_CAPIInvalidPhase /*line :76:24*/):
		panic(errInvalidPhase)
	}
}

func (c *httpCApiImpl) HttpContinue(r unsafe.Pointer, status uint64) {
	res := func() _Ctype_CAPIStatus{ _cgo0 := /*line :82:37*/r; var _cgo1 _Ctype_int = _Ctype_int /*line :82:45*/(status); _cgoCheckPointer(_cgo0, nil); return _Cfunc_envoyGoFilterHttpContinue(_cgo0, _cgo1); }()
	handleCApiStatus(res)
}

// Only may panic with errRequestFinished, errFilterDestroyed or errNotInGo,
// won't panic with errInvalidPhase and others, otherwise will cause deadloop, see RecoverPanic for the details.
func (c *httpCApiImpl) HttpSendLocalReply(r unsafe.Pointer, response_code int, body_text string, headers map[string]string, grpc_status int64, details string) {
	hLen := len(headers)
	strs := make([]string, 0, hLen)
	for k, v := range headers {
		strs = append(strs, k, v)
	}
	res := func() _Ctype_CAPIStatus{ _cgo0 := /*line :94:43*/r; var _cgo1 _Ctype_int = _Ctype_int /*line :94:51*/(response_code); _cgoBase2 := /*line :94:83*/&body_text; _cgo2 := /*line :94:68*/unsafe.Pointer(_cgoBase2); _cgoBase3 := /*line :94:111*/&strs; _cgo3 := /*line :94:96*/unsafe.Pointer(_cgoBase3); var _cgo4 _Ctype_longlong = _Ctype_longlong /*line :94:129*/(grpc_status); _cgoBase5 := /*line :94:159*/&details; _cgo5 := /*line :94:144*/unsafe.Pointer(_cgoBase5); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); _cgoCheckPointer(_cgoBase3, 0 == 0); _cgoCheckPointer(_cgoBase5, 0 == 0); return _Cfunc_envoyGoFilterHttpSendLocalReply(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }()
	handleCApiStatus(res)
}

func (c *httpCApiImpl) HttpSendPanicReply(r unsafe.Pointer, details string) {
	res := func() _Ctype_CAPIStatus{ _cgo0 := /*line :99:43*/r; _cgoBase1 := /*line :99:61*/&details; _cgo1 := /*line :99:46*/unsafe.Pointer(_cgoBase1); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); return _Cfunc_envoyGoFilterHttpSendPanicReply(_cgo0, _cgo1); }()
	handleCApiStatus(res)
}

func (c *httpCApiImpl) HttpGetHeader(r unsafe.Pointer, key *string, value *string) {
	res := func() _Ctype_CAPIStatus{ _cgo0 := /*line :104:38*/r; _cgo1 := /*line :104:41*/unsafe.Pointer(key); _cgo2 := /*line :104:62*/unsafe.Pointer(value); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgo2, nil); return _Cfunc_envoyGoFilterHttpGetHeader(_cgo0, _cgo1, _cgo2); }()
	handleCApiStatus(res)
}

func (c *httpCApiImpl) HttpCopyHeaders(r unsafe.Pointer, num uint64, bytes uint64) map[string][]string {
	// TODO: use a memory pool for better performance,
	// since these go strings in strs, will be copied into the following map.
	strs := make([]string, num*2)
	// but, this buffer can not be reused safely,
	// since strings may refer to this buffer as string data, and string is const in go.
	// we have to make sure the all strings is not using before reusing,
	// but strings may be alive beyond the request life.
	buf := make([]byte, bytes)
	sHeader := (*reflect.SliceHeader)(unsafe.Pointer(&strs))
	bHeader := (*reflect.SliceHeader)(unsafe.Pointer(&buf))

	res := func() _Ctype_CAPIStatus{ _cgo0 := /*line :120:40*/r; _cgo1 := /*line :120:43*/unsafe.Pointer(sHeader.Data); _cgo2 := /*line :120:73*/unsafe.Pointer(bHeader.Data); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgo2, nil); return _Cfunc_envoyGoFilterHttpCopyHeaders(_cgo0, _cgo1, _cgo2); }()
	handleCApiStatus(res)

	m := make(map[string][]string, num)
	for i := uint64(0); i < num*2; i += 2 {
		key := strs[i]
		value := strs[i+1]

		if v, found := m[key]; !found {
			m[key] = []string{value}
		} else {
			m[key] = append(v, value)
		}
	}
	runtime.KeepAlive(buf)
	return m
}

func (c *httpCApiImpl) HttpSetHeader(r unsafe.Pointer, key *string, value *string, add bool) {
	var act  /*line :139:10*/_Ctype_headerAction /*line :139:24*/
	if add {
		act = ( /*line :141:9*/_Ciconst_HeaderAdd /*line :141:19*/)
	} else {
		act = ( /*line :143:9*/_Ciconst_HeaderSet /*line :143:19*/)
	}
	res := func() _Ctype_CAPIStatus{ _cgo0 := /*line :145:44*/r; _cgo1 := /*line :145:47*/unsafe.Pointer(key); _cgo2 := /*line :145:68*/unsafe.Pointer(value); var _cgo3 _Ctype_headerAction = /*line :145:91*/act; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgo2, nil); return _Cfunc_envoyGoFilterHttpSetHeaderHelper(_cgo0, _cgo1, _cgo2, _cgo3); }()
	handleCApiStatus(res)
}

func (c *httpCApiImpl) HttpRemoveHeader(r unsafe.Pointer, key *string) {
	res := func() _Ctype_CAPIStatus{ _cgo0 := /*line :150:41*/r; _cgo1 := /*line :150:44*/unsafe.Pointer(key); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return _Cfunc_envoyGoFilterHttpRemoveHeader(_cgo0, _cgo1); }()
	handleCApiStatus(res)
}

func (c *httpCApiImpl) HttpGetBuffer(r unsafe.Pointer, bufferPtr uint64, value *string, length uint64) {
	buf := make([]byte, length)
	bHeader := (*reflect.SliceHeader)(unsafe.Pointer(&buf))
	sHeader := (*reflect.StringHeader)(unsafe.Pointer(value))
	sHeader.Data = bHeader.Data
	sHeader.Len = int(length)
	res := func() _Ctype_CAPIStatus{ _cgo0 := /*line :160:38*/r; var _cgo1 _Ctype_ulonglong = _Ctype_ulonglong /*line :160:52*/(bufferPtr); _cgo2 := /*line :160:65*/unsafe.Pointer(bHeader.Data); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo2, nil); return _Cfunc_envoyGoFilterHttpGetBuffer(_cgo0, _cgo1, _cgo2); }()
	handleCApiStatus(res)
}

func (c *httpCApiImpl) HttpSetBufferHelper(r unsafe.Pointer, bufferPtr uint64, value string, action api.BufferAction) {
	sHeader := (*reflect.StringHeader)(unsafe.Pointer(&value))
	var act  /*line :166:10*/_Ctype_bufferAction /*line :166:24*/
	switch action {
	case api.SetBuffer:
		act = ( /*line :169:9*/_Ciconst_Set /*line :169:13*/)
	case api.AppendBuffer:
		act = ( /*line :171:9*/_Ciconst_Append /*line :171:16*/)
	case api.PrependBuffer:
		act = ( /*line :173:9*/_Ciconst_Prepend /*line :173:17*/)
	}
	res := func() _Ctype_CAPIStatus{ _cgo0 := /*line :175:44*/r; var _cgo1 _Ctype_ulonglong = _Ctype_ulonglong /*line :175:58*/(bufferPtr); _cgo2 := /*line :175:71*/unsafe.Pointer(sHeader.Data); var _cgo3 _Ctype_int = _Ctype_int /*line :175:106*/(sHeader.Len); var _cgo4 _Ctype_bufferAction = /*line :175:121*/act; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo2, nil); return _Cfunc_envoyGoFilterHttpSetBufferHelper(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4); }()
	handleCApiStatus(res)
}

func (c *httpCApiImpl) HttpCopyTrailers(r unsafe.Pointer, num uint64, bytes uint64) map[string][]string {
	// TODO: use a memory pool for better performance,
	// but, should be very careful, since string is const in go,
	// and we have to make sure the strings is not using before reusing,
	// strings may be alive beyond the request life.
	strs := make([]string, num*2)
	buf := make([]byte, bytes)
	sHeader := (*reflect.SliceHeader)(unsafe.Pointer(&strs))
	bHeader := (*reflect.SliceHeader)(unsafe.Pointer(&buf))

	res := func() _Ctype_CAPIStatus{ _cgo0 := /*line :189:41*/r; _cgo1 := /*line :189:44*/unsafe.Pointer(sHeader.Data); _cgo2 := /*line :189:74*/unsafe.Pointer(bHeader.Data); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgo2, nil); return _Cfunc_envoyGoFilterHttpCopyTrailers(_cgo0, _cgo1, _cgo2); }()
	handleCApiStatus(res)

	m := make(map[string][]string, num)
	for i := uint64(0); i < num*2; i += 2 {
		key := strs[i]
		value := strs[i+1]

		if v, found := m[key]; !found {
			m[key] = []string{value}
		} else {
			m[key] = append(v, value)
		}
	}
	return m
}

func (c *httpCApiImpl) HttpSetTrailer(r unsafe.Pointer, key *string, value *string, add bool) {
	var act  /*line :207:10*/_Ctype_headerAction /*line :207:24*/
	if add {
		act = ( /*line :209:9*/_Ciconst_HeaderAdd /*line :209:19*/)
	} else {
		act = ( /*line :211:9*/_Ciconst_HeaderSet /*line :211:19*/)
	}
	res := func() _Ctype_CAPIStatus{ _cgo0 := /*line :213:39*/r; _cgo1 := /*line :213:42*/unsafe.Pointer(key); _cgo2 := /*line :213:63*/unsafe.Pointer(value); var _cgo3 _Ctype_headerAction = /*line :213:86*/act; _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); _cgoCheckPointer(_cgo2, nil); return _Cfunc_envoyGoFilterHttpSetTrailer(_cgo0, _cgo1, _cgo2, _cgo3); }()
	handleCApiStatus(res)
}

func (c *httpCApiImpl) HttpRemoveTrailer(r unsafe.Pointer, key *string) {
	res := func() _Ctype_CAPIStatus{ _cgo0 := /*line :218:42*/r; _cgo1 := /*line :218:45*/unsafe.Pointer(key); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgo1, nil); return _Cfunc_envoyGoFilterHttpRemoveTrailer(_cgo0, _cgo1); }()
	handleCApiStatus(res)
}

func (c *httpCApiImpl) HttpGetStringValue(rr unsafe.Pointer, id int) (string, bool) {
	r := (*httpRequest)(rr)
	var value string
	// add a lock to protect filter->req_->strValue field in the Envoy side, from being writing concurrency,
	// since there might be multiple concurrency goroutines invoking this API on the Go side.
	r.mutex.Lock()
	defer r.mutex.Unlock()
	res := func() _Ctype_CAPIStatus{ _cgo0 := /*line :229:43*/unsafe.Pointer(r.req); var _cgo1 _Ctype_int = _Ctype_int /*line :229:71*/(id); _cgoBase2 := /*line :229:92*/&value; _cgo2 := /*line :229:77*/unsafe.Pointer(_cgoBase2); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return _Cfunc_envoyGoFilterHttpGetStringValue(_cgo0, _cgo1, _cgo2); }()
	if res == ( /*line :230:12*/_Ciconst_CAPIValueNotFound /*line :230:30*/) {
		return "", false
	}
	handleCApiStatus(res)
	// copy the memory from c to Go.
	return strings.Clone(value), true
}

func (c *httpCApiImpl) HttpGetIntegerValue(r unsafe.Pointer, id int) (uint64, bool) {
	var value uint64
	res := func() _Ctype_CAPIStatus{ _cgo0 := /*line :240:44*/r; var _cgo1 _Ctype_int = _Ctype_int /*line :240:52*/(id); _cgoBase2 := /*line :240:73*/&value; _cgo2 := /*line :240:58*/unsafe.Pointer(_cgoBase2); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase2, 0 == 0); return _Cfunc_envoyGoFilterHttpGetIntegerValue(_cgo0, _cgo1, _cgo2); }()
	if res == ( /*line :241:12*/_Ciconst_CAPIValueNotFound /*line :241:30*/) {
		return 0, false
	}
	handleCApiStatus(res)
	return value, true
}

func (c *httpCApiImpl) HttpGetDynamicMetadata(rr unsafe.Pointer, filterName string) map[string]interface{} {
	r := (*httpRequest)(rr)
	var buf []byte
	r.mutex.Lock()
	defer r.mutex.Unlock()
	r.sema.Add(1)
	res := func() _Ctype_CAPIStatus{ _cgo0 := /*line :254:47*/unsafe.Pointer(r.req); _cgoBase1 := /*line :254:85*/&filterName; _cgo1 := /*line :254:70*/unsafe.Pointer(_cgoBase1); _cgoBase2 := /*line :254:114*/&buf; _cgo2 := /*line :254:99*/unsafe.Pointer(_cgoBase2); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); _cgoCheckPointer(_cgoBase2, 0 == 0); return _Cfunc_envoyGoFilterHttpGetDynamicMetadata(_cgo0, _cgo1, _cgo2); }()
	if res == ( /*line :255:12*/_Ciconst_CAPIYield /*line :255:22*/) {
		atomic.AddInt32(&r.waitingOnEnvoy, 1)
		r.sema.Wait()
	} else {
		r.sema.Done()
		handleCApiStatus(res)
	}
	// copy the memory from c to Go.
	var meta structpb.Struct
	proto.Unmarshal(buf, &meta)
	return meta.AsMap()
}

func (c *httpCApiImpl) HttpSetDynamicMetadata(r unsafe.Pointer, filterName string, key string, value interface{}) {
	v, err := structpb.NewValue(value)
	if err != nil {
		panic(err)
	}
	buf, err := proto.Marshal(v)
	if err != nil {
		panic(err)
	}
	res := func() _Ctype_CAPIStatus{ _cgo0 := /*line :277:47*/r; _cgoBase1 := /*line :277:65*/&filterName; _cgo1 := /*line :277:50*/unsafe.Pointer(_cgoBase1); _cgoBase2 := /*line :277:94*/&key; _cgo2 := /*line :277:79*/unsafe.Pointer(_cgoBase2); _cgoBase3 := /*line :277:116*/&buf; _cgo3 := /*line :277:101*/unsafe.Pointer(_cgoBase3); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); _cgoCheckPointer(_cgoBase2, 0 == 0); _cgoCheckPointer(_cgoBase3, 0 == 0); return _Cfunc_envoyGoFilterHttpSetDynamicMetadata(_cgo0, _cgo1, _cgo2, _cgo3); }()
	handleCApiStatus(res)
}

func (c *httpCApiImpl) HttpLog(level api.LogType, message string) {
	func() { var _cgo0 _Ctype_uint32_t = _Ctype_uint32_t /*line :282:35*/(level); _cgoBase1 := /*line :282:59*/&message; _cgo1 := /*line :282:44*/unsafe.Pointer(_cgoBase1); _cgoCheckPointer(_cgoBase1, 0 == 0); _Cfunc_envoyGoFilterHttpLog(_cgo0, _cgo1); }()
}

func (c *httpCApiImpl) HttpLogLevel() api.LogType {
	return api.LogType(( /*line :286:21*/_Cfunc_envoyGoFilterHttpLogLevel /*line :286:47*/)())
}

func (c *httpCApiImpl) HttpFinalize(r unsafe.Pointer, reason int) {
	func() { _cgo0 := /*line :290:30*/r; var _cgo1 _Ctype_int = _Ctype_int /*line :290:38*/(reason); _cgoCheckPointer(_cgo0, nil); _Cfunc_envoyGoFilterHttpFinalize(_cgo0, _cgo1); }()
}

var cAPI api.HttpCAPI = &httpCApiImpl{}

// SetHttpCAPI for mock cAPI
func SetHttpCAPI(api api.HttpCAPI) {
	cAPI = api
}

func (c *httpCApiImpl) HttpSetStringFilterState(r unsafe.Pointer, key string, value string, stateType api.StateType, lifeSpan api.LifeSpan, streamSharing api.StreamSharing) {
	res := func() _Ctype_CAPIStatus{ _cgo0 := /*line :301:49*/r; _cgoBase1 := /*line :301:67*/&key; _cgo1 := /*line :301:52*/unsafe.Pointer(_cgoBase1); _cgoBase2 := /*line :301:89*/&value; _cgo2 := /*line :301:74*/unsafe.Pointer(_cgoBase2); var _cgo3 _Ctype_int = _Ctype_int /*line :301:103*/(stateType); var _cgo4 _Ctype_int = _Ctype_int /*line :301:121*/(lifeSpan); var _cgo5 _Ctype_int = _Ctype_int /*line :301:138*/(streamSharing); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); _cgoCheckPointer(_cgoBase2, 0 == 0); return _Cfunc_envoyGoFilterHttpSetStringFilterState(_cgo0, _cgo1, _cgo2, _cgo3, _cgo4, _cgo5); }()
	handleCApiStatus(res)
}

func (c *httpCApiImpl) HttpGetStringFilterState(rr unsafe.Pointer, key string) string {
	r := (*httpRequest)(rr)
	var value string
	r.mutex.Lock()
	defer r.mutex.Unlock()
	r.sema.Add(1)
	res := func() _Ctype_CAPIStatus{ _cgo0 := /*line :311:49*/unsafe.Pointer(r.req); _cgoBase1 := /*line :311:87*/&key; _cgo1 := /*line :311:72*/unsafe.Pointer(_cgoBase1); _cgoBase2 := /*line :311:109*/&value; _cgo2 := /*line :311:94*/unsafe.Pointer(_cgoBase2); _cgoCheckPointer(_cgo0, nil); _cgoCheckPointer(_cgoBase1, 0 == 0); _cgoCheckPointer(_cgoBase2, 0 == 0); return _Cfunc_envoyGoFilterHttpGetStringFilterState(_cgo0, _cgo1, _cgo2); }()
	if res == ( /*line :312:12*/_Ciconst_CAPIYield /*line :312:22*/) {
		atomic.AddInt32(&r.waitingOnEnvoy, 1)
		r.sema.Wait()
	} else {
		r.sema.Done()
		handleCApiStatus(res)
	}

	return strings.Clone(value)
}
